/*
 * Copyright 2010 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.jribble

import com.google.jribble.ast._
import org.scalacheck.{Arbitrary, Gen}

object Generators {

  //todo (grek): jribble identifiers (names) allow more characters than those generated by standard Gen.identifier
  def identifier = Gen.resize(7, Gen.identifier)

  def pkg: Gen[Package] = for(x <- identifier; xs <- Gen.resize(2, Gen.listOf(identifier))) yield
    Package(x + (xs.map("/" + _) mkString))

  def ref: Gen[Ref] = {
    implicit val arbPackage = Arbitrary(pkg)
    for(name <- identifier; p <- Arbitrary.arbitrary[Option[Package]]) yield Ref(p, name)
  }

  def primitive: Gen[Primitive] =
    for (name <- Gen.oneOf("Z", "B", "C", "D", "F", "I", "J", "S")) yield Primitive(name)

  def array: Gen[Array] = for (t <- typ) yield Array(t)

  def typ: Gen[Type] = Gen.oneOf(ref, primitive, Gen.lzy(array))

  def paramsDef: Gen[List[ParamDef]] = {
    val paramDef: Gen[ParamDef] = for (n <- identifier; t <- typ) yield ParamDef(n, t)
    Gen.resize(4, Gen.listOf(paramDef))
  }

  def params: Gen[List[Expression]] = Gen.resize(4, Gen.listOf(expression(0)))

  //todo (grek): implement generation of all literals
  def literal: Gen[Literal] = {
    import Arbitrary._
    //todo (grek): once parsing of escaped is implemented we should switch to broader domain of strings
    val stringLiteral = for (x <- Gen.listOf(Gen.alphaNumChar)) yield StringLiteral(x mkString)
    val charLiteral = for (x <- arbitrary[Char]) yield CharLiteral(x)
    val booleanLiteral = for (x <- arbitrary[Boolean]) yield BooleanLiteral(x)
    stringLiteral | charLiteral | booleanLiteral
  }
  def varRef = identifier.map(VarRef)
  def signature: Gen[Signature] = for {
    on <- ref
    n <- identifier
    paramTypes <- Gen.listOf(typ)
    r <- returnType
  } yield Signature(on, n, paramTypes, r)
  
  def newCall(implicit depth: Int): Gen[NewCall] = for (s <- signature; p <- params) yield NewCall(s, p)
  def methodCall(implicit depth: Int): Gen[MethodCall] =
    for (on <- expression; s <- signature; p <- params) yield MethodCall(on, s, p)
  def staticMethodCall(implicit depth: Int): Gen[StaticMethodCall] =
    for (c <- ref; s <- signature; p <- params) yield StaticMethodCall(c, s, p)

  def expression(implicit depth: Int): Gen[Expression] = {
    val nonRecursive = Gen.frequency((2, literal), (1, varRef), (1, Gen.value(ThisRef)))
    val recursive = Gen.oneOf(Gen.lzy(newCall(depth+1)), Gen.lzy(methodCall(depth+1)),
      Gen.lzy(staticMethodCall(depth+1)))

    Gen.frequency((depth+1, nonRecursive), (1, recursive))
  }

  def varDef: Gen[VarDef] = for (t <- typ; n <- identifier; v <- expression(0)) yield VarDef(t, n, v)
  def assignment: Gen[Assignment] = for (n <- identifier; v <- expression(0)) yield Assignment(n, v)

  def methodStatement: Gen[MethodStatement] = Gen.oneOf(varDef, assignment, expression(0))
  def methodStatements: Gen[List[MethodStatement]] = Gen.listOf(methodStatement)

  def constructorSuperCall: Gen[SuperConstructorCall] =
    for (s <- signature; p <- params) yield SuperConstructorCall(s, p)
  //we shuffle the list because in jribble there is no requirement that super constructor call is
  def constructorBody: Gen[Block[ConstructorStatement]] = for {
      s <- Gen.resize(1, Gen.listOf(constructorSuperCall))
      ss <- methodStatements
    } yield Block(scala.util.Random.shuffle(s ::: ss))
  def constructor: Gen[Constructor] =
    for (n <- identifier; p <- paramsDef; b <- constructorBody) yield Constructor(n, p, b)

  def methodBody: Gen[Block[MethodStatement]] = methodStatements map (Block(_))
  def returnType = typ | Void
  def methodDef: Gen[MethodDef] =
    for (t <- returnType; n <- identifier; p <- paramsDef; b <- methodBody) yield MethodDef(t, n, p, b)

  def classModifiers: Gen[Set[String]] = {
    val modif = Gen.oneOf("public", "final")
    Gen.resize(2, Gen.listOf(modif)).map(_.toSet)
  }

  def interfaceModifiers: Gen[Set[String]] = {
    val modif = Gen.oneOf("public", "abstract")
    Gen.resize(2, Gen.listOf(modif)).map(_.toSet)
  }

  def extendsDef: Gen[Option[Ref]] = Arbitrary.arbitrary[Option[Ref]]

  def implementsDef: Gen[List[Ref]] = Gen.resize(3, Gen.listOf(ref))

  def classBody: Gen[List[Either[Constructor, MethodDef]]] = for {
    cs <- Gen.resize(3, Gen.listOf(constructor))
    ms <- Gen.resize(5, Gen.listOf(methodDef))
  } yield cs.map(Left(_)) ++ ms.map(Right(_))

  def interfaceBody: Gen[List[MethodDef]] = for {
    ms <- Gen.resize(5, Gen.listOf(methodDef.filter(_.body.statements.isEmpty)))
  } yield ms

  def classDef: Gen[ClassDef] = for {
    m <- classModifiers
    n <- ref
    e <- extendsDef
    i <- implementsDef
    b <- classBody
  } yield ClassDef(m, n, e, i, b)

  def interfaceDef: Gen[InterfaceDef] = for {
    m <- interfaceModifiers
    n <- ref
    e <- extendsDef
    b <- interfaceBody
  } yield InterfaceDef(m, n, e, b)

  implicit val arbRef = Arbitrary(ref)
  implicit val arbPackage = Arbitrary(pkg)
  implicit val arbPrimitive = Arbitrary(primitive)
  implicit val arbArray = Arbitrary(array)
  implicit val arbType = Arbitrary(typ)
  implicit val arbParamsDef = Arbitrary(paramsDef)
  implicit val arbLiteral = Arbitrary(literal)
  implicit val arbSignature = Arbitrary(signature)
  implicit val arbNewCall = Arbitrary(newCall(0))
  implicit val arbMethodCall = Arbitrary(methodCall(0))
  implicit val arbStaticMethodCall = Arbitrary(staticMethodCall(0))
  implicit val arbExpression = Arbitrary(expression(0))
  implicit val arbVarDef = Arbitrary(varDef)
  implicit val arbAssignment = Arbitrary(assignment)
  implicit val arbMethodStatement = Arbitrary(methodStatement)
  implicit val arbMethodBody = Arbitrary(methodBody)
  implicit val arbConstructorStatements = Arbitrary(constructorBody) 
  implicit val arbConstructor = Arbitrary(constructor)
  implicit val arbMethodDef = Arbitrary(methodDef)
  implicit val arbClassDef = Arbitrary(classDef)
  implicit val arbInterfaceDef = Arbitrary(interfaceDef)
}
