/*
 * Copyright 2010 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.jribble

import com.google.jribble.ast._
import org.scalacheck.{Arbitrary, Gen}

object Generators {

  //todo (grek): jribble identifiers (names) allow more characters than those generated by standard Gen.identifier
  def identifier = Gen.resize(7, Gen.identifier)

  def pkg: Gen[Package] = for(x <- identifier; xs <- Gen.resize(2, Gen.listOf(identifier))) yield
    Package(x + (xs.map("." + _) mkString))

  def className: Gen[ClassName] = for(name <- identifier; p <- pkg) yield ClassName(p, name)

  def primitive: Gen[Primitive] =
    for (name <- Gen.oneOf("byte", "short", "int", "long", "float", "double", "boolean", "char")) yield Primitive(name)

  def array: Gen[Array] = for (t <- typ) yield Array(t)

  def typ: Gen[Type] = Gen.oneOf(className, primitive, Gen.lzy(array))

  def paramsDef: Gen[List[ParamDef]] = {
    val paramDef: Gen[ParamDef] = for (n <- identifier; t <- typ) yield ParamDef(n, t)
    Gen.resize(4, Gen.listOf(paramDef))
  }

  def params: Gen[List[Expression]] = Gen.resize(4, Gen.listOf(expression))

  //todo (grek): implement generation of all literals
  def literal: Gen[Literal] = {
    import Arbitrary._
    //todo (grek): once parsing of escaped is implemented we should switch to broader domain of strings
    val stringLiteral = for (x <- Gen.listOf(Gen.alphaNumChar)) yield StringLiteral(x mkString)
    val charLiteral = for (x <- arbitrary[Char]) yield CharLiteral(x)
    val booleanLiteral = for (x <- arbitrary[Boolean]) yield BooleanLiteral(x)
    stringLiteral | charLiteral | booleanLiteral
  }
  def varRef = identifier.map(VarRef)
  def signature: Gen[Signature] =
    for (r <- returnType; paramTypes <- Gen.listOf(typ)) yield Signature(r, paramTypes)
  def newCall: Gen[NewCall] = for (c <- className; s <- signature; p <- params) yield NewCall(c, s, p)
  def methodCall: Gen[MethodCall] =
    for (on <- expression; s <- signature; n <- identifier; p <- params) yield MethodCall(on, s, n, p)
  def staticMethodCall: Gen[StaticMethodCall] =
    for (c <- className; s <- signature; n <- identifier; p <- params) yield StaticMethodCall(c, s, n, p)

  def expression: Gen[Expression] =
    {
      Gen.frequency(
        (5, literal),
        (1, varRef),
        (1, ThisRef),
        (1, Gen.lzy(newCall)),
        (1, Gen.lzy(methodCall)),
        (1, Gen.lzy(staticMethodCall))
      )
    }

  def varDef: Gen[VarDef] = for (t <- typ; n <- identifier; v <- expression) yield VarDef(t, n, v)
  def assignment: Gen[Assignment] = for (n <- identifier; v <- expression) yield Assignment(n, v)

  def methodStatement: Gen[MethodStatement] = Gen.oneOf(varDef, assignment, expression)
  def methodStatements: Gen[List[MethodStatement]] = Gen.listOf(methodStatement)

  def constructorSuperCall: Gen[SuperConstructorCall] =
    for (s <- signature; p <- params) yield SuperConstructorCall(s, p)
  //we shuffle the list because in jribble there is no requirement that super constructor call is
  def constructorBody: Gen[List[ConstructorStatement]] = for {
      s <- Gen.resize(1, Gen.listOf(constructorSuperCall))
      ss <- methodStatements
    } yield scala.util.Random.shuffle(s ::: ss)
  def constructor: Gen[Constructor] =
    for (n <- identifier; p <- paramsDef; b <- constructorBody) yield Constructor(n, p, b)

  def methodBody = methodStatements
  def returnType = typ | Void
  def methodDef: Gen[MethodDef] =
    for (t <- returnType; n <- identifier; p <- paramsDef; b <- methodBody) yield MethodDef(t, n, p, b)

  def classModifiers: Gen[Set[String]] = {
    val modif = Gen.oneOf("public", "final")
    Gen.resize(2, Gen.listOf(modif)).map(_.toSet)
  }
  def extendsDef: Gen[Option[ClassName]] = Arbitrary.arbitrary[Option[ClassName]]

  def implementsDef: Gen[List[ClassName]] = Gen.resize(3, Gen.listOf(className))

  def classBody: Gen[List[Either[Constructor, MethodDef]]] = for {
    cs <- Gen.resize(3, Gen.listOf(constructor))
    ms <- Gen.resize(5, Gen.listOf(methodDef))
  } yield cs.map(Left(_)) ++ ms.map(Right(_))

  def classDef: Gen[ClassDef] = for {
    m <- classModifiers
    n <- className
    e <- extendsDef
    i <- implementsDef
    b <- classBody
  } yield ClassDef(m, n, e, i, b)

  implicit val arbClassName = Arbitrary(className)
  implicit val arbPackage = Arbitrary(pkg)
  implicit val arbPrimitive = Arbitrary(primitive)
  implicit val arbArray = Arbitrary(array)
  implicit val arbType = Arbitrary(typ)
  implicit val arbParamsDef = Arbitrary(paramsDef)
  implicit val arbLiteral = Arbitrary(literal)
  implicit val arbSignature = Arbitrary(signature)
  implicit val arbNewCall = Arbitrary(newCall)
  implicit val arbMethodCall = Arbitrary(methodCall)
  implicit val arbStaticMethodCall = Arbitrary(staticMethodCall)
  implicit val arbExpression = Arbitrary(expression)
  implicit val arbVarDef = Arbitrary(varDef)
  implicit val arbAssignment = Arbitrary(assignment)
  implicit val arbMethodStatement = Arbitrary(methodStatement)
  implicit val arbMethodStatements = Arbitrary(methodStatements)
  implicit val arbConstructorStatements = Arbitrary(constructorBody) 
  implicit val arbConstructor = Arbitrary(constructor)
  implicit val arbMethodDef = Arbitrary(methodDef)
  implicit val arbClassDef = Arbitrary(classDef)
}
